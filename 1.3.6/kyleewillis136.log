%cd "C:\Users\k.willis\Documents\Python\1.3.6"
# Mon, 14 Nov 2016 09:19:24
#11/14/2016

# Mon, 14 Nov 2016 09:20:17
(4,2,1)
#[Out]# (4, 2, 1)
# Mon, 14 Nov 2016 09:22:50
someValues = ('a', 'b', 3)
# Mon, 14 Nov 2016 09:23:14
someValues[0]
#[Out]# 'a'
# Mon, 14 Nov 2016 09:23:22
someValues[1]
#[Out]# 'b'
# Mon, 14 Nov 2016 09:25:16
#7a. The output is b (and I predicted that) because the string b was saved with the value in the list of 1. 

# Mon, 14 Nov 2016 09:26:13
#7b. Will list all the options because it's a slice, but it's the whole thing, if that makes sense

# Mon, 14 Nov 2016 09:26:40
someValues[0:2]
#[Out]# ('a', 'b')
# Mon, 14 Nov 2016 09:27:31
#7b. It didn't come out with 3 because it doesn't include the last value, it stops at it. I forgot about that.

# Mon, 14 Nov 2016 09:28:44
someValues[2] = '3'
# Mon, 14 Nov 2016 09:29:38
a = 1-
# Mon, 14 Nov 2016 09:29:42
a = 10
# Mon, 14 Nov 2016 09:29:52
b = (9,10, 11)
# Mon, 14 Nov 2016 09:29:54
b
#[Out]# (9, 10, 11)
# Mon, 14 Nov 2016 09:30:03
a = 15
# Mon, 14 Nov 2016 09:30:05
b
#[Out]# (9, 10, 11)
# Mon, 14 Nov 2016 09:30:14
a
#[Out]# 15
# Mon, 14 Nov 2016 09:30:38
b[1] == 10
#[Out]# True
# Mon, 14 Nov 2016 09:31:23
#8a. It's a boolean, a conditional which is asking if b's value of 1 is equal to 10. It was and is therefore true.

# Mon, 14 Nov 2016 09:31:34
b = (9, a, 11)
# Mon, 14 Nov 2016 09:31:37
b[1]
#[Out]# 15
# Mon, 14 Nov 2016 09:32:05
#8b. The value of a was changed earlier in the question, and you just updated b so it matched that.

# Mon, 14 Nov 2016 09:32:42
values = ['a', 'b', 3]
# Mon, 14 Nov 2016 09:32:43
values
#[Out]# ['a', 'b', 3]
# Mon, 14 Nov 2016 09:32:47
values[1]
#[Out]# 'b'
# Mon, 14 Nov 2016 09:32:53
values[1:]
#[Out]# ['b', 3]
# Mon, 14 Nov 2016 09:34:30
#9. It gives you a list that starts at the whatever element has the value of 1 and continues until the end. 

# Mon, 14 Nov 2016 09:35:14
values[2] == 3
#[Out]# True
# Mon, 14 Nov 2016 09:35:22
values[2] + 5
#[Out]# 8
# Mon, 14 Nov 2016 09:35:26
values[2]
#[Out]# 3
# Mon, 14 Nov 2016 09:37:10
#10. The first statement changes the element with the value of 2, which means that the second statement will be false.
values[2] = '3'
# Mon, 14 Nov 2016 09:37:17
values[2] == 3
#[Out]# False
# Mon, 14 Nov 2016 09:38:41
values = values + [4,5]
# Mon, 14 Nov 2016 09:39:13
#11a. I think it'll just add the two values to the list.
values
#[Out]# ['a', 'b', '3', 4, 5]
# Mon, 14 Nov 2016 09:39:49
#It did that because the statement set values equal to the previous elements and the new ones.

# Mon, 14 Nov 2016 09:40:05
values.append([6,7])
# Mon, 14 Nov 2016 09:40:07
values
#[Out]# ['a', 'b', '3', 4, 5, [6, 7]]
# Mon, 14 Nov 2016 09:40:19
values[5]
#[Out]# [6, 7]
# Mon, 14 Nov 2016 09:40:27
values.append(6)
# Mon, 14 Nov 2016 09:40:30
values
#[Out]# ['a', 'b', '3', 4, 5, [6, 7], 6]
# Mon, 14 Nov 2016 09:42:00
#11b. Append, from my definition of it, basically means to add, so the .append part of the input is pretty much saying "add these values to your list!"

# Mon, 14 Nov 2016 09:42:33
#And that last 6 was supposed to be an 8. Whoops.)

# Mon, 14 Nov 2016 09:45:46
#12. list.count(x) counts the number of times x appears in the list

# Mon, 14 Nov 2016 09:46:08
values = values + 9
# Mon, 14 Nov 2016 09:47:17
#13. The 9 isn't part of a list (it's an int) and so can't be added to values. An int can't be added in that way.

# Mon, 14 Nov 2016 09:47:41
values += [9,10]
# Mon, 14 Nov 2016 09:47:43
values
#[Out]# ['a', 'b', '3', 4, 5, [6, 7], 6, 9, 10]
# Mon, 14 Nov 2016 09:48:02
x = 6
# Mon, 14 Nov 2016 09:48:07
x*= 3
# Mon, 14 Nov 2016 09:48:09
x
#[Out]# 18
# Mon, 14 Nov 2016 09:49:22
#14. Python doesn't care what specific operation you're doing when you set a variable equal to a number, so the shorthand works (assuming you set it up right) for both * and +

# Mon, 14 Nov 2016 09:49:54
import random
# Mon, 14 Nov 2016 09:50:06
random.choice(values)
#[Out]# 10
# Mon, 14 Nov 2016 09:50:19
random.randint(5,8)
#[Out]# 5
# Mon, 14 Nov 2016 09:50:29
random.uniform(5,8)
#[Out]# 5.256469639689146
# Mon, 14 Nov 2016 09:54:45
%run "c:\users\k4410~1.wil\appdata\local\temp\tmpcauarm.py"# Mon, 14 Nov 2016 09:54:52
%run "c:\users\k4410~1.wil\appdata\local\temp\tmpq4vefl.py"# Mon, 14 Nov 2016 09:55:01
roll_two_dice()
# Mon, 14 Nov 2016 09:55:04
roll_two_dice()
# Mon, 14 Nov 2016 09:55:05
roll_two_dice()
# Mon, 14 Nov 2016 10:01:29
%run "c:\users\k4410~1.wil\appdata\local\temp\tmp6nxnkh.py"# Mon, 14 Nov 2016 10:01:37
guess_letter()
# Mon, 14 Nov 2016 10:01:46
%run "c:\users\k4410~1.wil\appdata\local\temp\tmpgtfqge.py"# Mon, 14 Nov 2016 10:01:48
guess_letter()
# Mon, 14 Nov 2016 10:02:53
%run "c:\users\k4410~1.wil\appdata\local\temp\tmpxyhuvd.py"# Mon, 14 Nov 2016 10:02:55
guess_letter()
# Mon, 14 Nov 2016 10:03:03
%run "c:\users\k4410~1.wil\appdata\local\temp\tmphyifka.py"# Mon, 14 Nov 2016 10:03:06
guess_letter()
# Mon, 14 Nov 2016 10:04:04
%run "c:\users\k4410~1.wil\appdata\local\temp\tmp1vdfem.py"# Mon, 14 Nov 2016 10:04:07
guess_letter()
# Mon, 14 Nov 2016 10:04:44
%logstop
%cd "C:\Users\k.willis\Documents\Python\1.3.6"
# Tue, 15 Nov 2016 09:17:42
#11/15/2016

# Tue, 15 Nov 2016 09:19:10
%run C:/Users/k.willis/Documents/Python/1.3.6/kyleewillis136.py# Tue, 15 Nov 2016 09:19:17
guess_letter()
# Tue, 15 Nov 2016 09:19:19
guess_letter()
# Tue, 15 Nov 2016 09:19:22
guess_letter()
# Tue, 15 Nov 2016 09:19:23
guess_letter()
# Tue, 15 Nov 2016 09:19:30
#That was 17

# Tue, 15 Nov 2016 09:19:44
#CONCLUSION

# Tue, 15 Nov 2016 09:24:12
#1. a's characters are simply a string, while b's are a tuple and c's are a list. A string isn't a list, it's just a bunch of characters strung together. A tuple is a list, but its values can't be changed. The values in a list can be changed.

# Tue, 15 Nov 2016 09:28:53
#2. A programmer might want to use a tuple instead of a list when they need a variable to stay the same value after being changed or they don't want to accidentally add values, and a programmer might want to use a list instead of a tuple when the variable needs to change or they aren't sure about the value the variable should have. Tuples also run faster than lists, and they make your code safer (with the assurance of being constant).

# Tue, 15 Nov 2016 09:28:57
% logstop
